// Load live options data from Python-generated JSON file
#![allow(dead_code)]

use crate::calibration::market_option::{MarketOption, OptionType};
use serde::{Deserialize, Serialize};
use std::error::Error;
use std::fs;

#[derive(Debug, Deserialize, Serialize)]
struct OptionsDataFile {
    symbol: String,
    spot_price: f64,
    expiration_date: String,
    time_to_expiry: f64,
    fetched_at: String,
    options: Vec<OptionJson>,
}

#[derive(Debug, Deserialize, Serialize)]
struct OptionJson {
    strike: f64,
    bid: f64,
    ask: f64,
    volume: i32,
    open_interest: i32,
    option_type: String,  // "Call" or "Put"
}

/// Load options from JSON file (generated by Python yfinance script)
pub fn load_options_from_json(filepath: &str) -> Result<(f64, Vec<MarketOption>), Box<dyn Error>> {
    let contents = fs::read_to_string(filepath)?;
    let data: OptionsDataFile = serde_json::from_str(&contents)?;
    
    let spot = data.spot_price;
    let time_to_expiry = data.time_to_expiry;
    
    let mut options = Vec::new();
    
    for opt in data.options {
        let option_type = match opt.option_type.as_str() {
            "Call" => OptionType::Call,
            "Put" => OptionType::Put,
            _ => continue,
        };
        
        options.push(MarketOption {
            strike: opt.strike,
            time_to_expiry,
            option_type,
            bid: opt.bid,
            ask: opt.ask,
            volume: opt.volume,
            open_interest: opt.open_interest,
        });
    }
    
    println!("✓ Loaded {} options from {}", options.len(), filepath);
    println!("  Symbol: {}", data.symbol);
    println!("  Spot: ${:.2}", spot);
    println!("  Expiration: {}", data.expiration_date);
    println!("  Fetched: {}", data.fetched_at);
    
    Ok((spot, options))
}

/// Filter loaded options by liquidity
pub fn filter_liquid_options(
    options: Vec<MarketOption>,
    min_volume: i32,
    max_spread_pct: f64,
) -> Vec<MarketOption> {
    let initial_count = options.len();
    
    let filtered: Vec<MarketOption> = options
        .into_iter()
        .filter(|opt| {
            let spread_pct = ((opt.ask - opt.bid) / opt.mid_price()) * 100.0;
            opt.volume >= min_volume && spread_pct <= max_spread_pct
        })
        .collect();
    
    println!(
        "✓ Filtered to {} liquid options ({} removed)",
        filtered.len(),
        initial_count - filtered.len()
    );
    println!("  Min volume: {}", min_volume);
    println!("  Max spread: {:.1}%", max_spread_pct);
    
    filtered
}
