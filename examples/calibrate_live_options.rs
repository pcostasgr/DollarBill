// Test loading live options from Python-generated JSON
use dollarbill::market_data::options_json_loader::{load_options_from_json, filter_liquid_options};
use dollarbill::calibration::heston_calibrator::{calibrate_heston, CalibParams};
use dollarbill::market_data::symbols::load_enabled_stocks;
use serde::Deserialize;
use serde_json;
use chrono;
use std::fs;

#[derive(Debug, Deserialize)]
struct SignalsConfig {
    analysis: AnalysisConfig,
    calibration: CalibrationConfig,
    options: OptionsConfig,
}

#[derive(Debug, Deserialize)]
struct AnalysisConfig {
    risk_free_rate: f64,
    liquidity_filters: LiquidityFilters,
    edge_thresholds: EdgeThresholds,
}

#[derive(Debug, Deserialize)]
struct LiquidityFilters {
    min_volume: i32,
    max_spread_pct: f64,
}

#[derive(Debug, Deserialize)]
struct EdgeThresholds {
    min_edge_dollars: f64,
    min_delta: f64,
}

#[derive(Debug, Deserialize)]
struct CalibrationConfig {
    tolerance: f64,
    max_iterations: usize,
}

#[derive(Debug, Deserialize)]
struct OptionsConfig {
    default_time_to_expiry_days: usize,
    min_time_to_expiry_days: usize,
    max_time_to_expiry_days: usize,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("==============================================");
    println!("LIVE OPTIONS CALIBRATION (Python ‚Üí Rust)");
    println!("==============================================\n");

    // Load configuration
    let config_content = fs::read_to_string("config/signals_config.json")
        .map_err(|e| format!("Failed to read signals config file: {}", e))?;
    let config: SignalsConfig = serde_json::from_str(&config_content)
        .map_err(|e| format!("Failed to parse signals config file: {}", e))?;

    println!("üìã Loaded signals configuration from config/signals_config.json");

    // Load enabled symbols
    let symbols = load_enabled_stocks()?;
    println!("üéØ Calibrating Heston for symbols: {:?}", symbols);
    println!();

    for symbol in &symbols {
        println!("üîç Calibrating {}...", symbol);

        // 1. Load options from JSON (generated by Python)
        let json_file = format!("data/{}_options_live.json", symbol.to_lowercase());
        println!("  Step 1: Loading options from {}...", json_file);

        let (spot, all_options) = match load_options_from_json(&json_file) {
            Ok(data) => data,
            Err(e) => {
                println!("  ‚ùå Failed to load options: {}", e);
                continue;
            }
        };
        println!("  Loaded {} options, spot = ${:.2}", all_options.len(), spot);

        // 2. Filter for liquid options
        println!("  Step 2: Filtering for liquid options...");
        let liquid_options = filter_liquid_options(all_options, config.analysis.liquidity_filters.min_volume, config.analysis.liquidity_filters.max_spread_pct);

        if liquid_options.is_empty() {
            println!("  ‚ùå No liquid options found!");
            continue;
        }
        println!("  Found {} liquid options", liquid_options.len());

        // 3. Calibrate Heston model
        println!("  Step 3: Calibrating Heston model to market prices...");
        let initial_guess = CalibParams {
            kappa: 2.0,
            theta: 0.25,
            sigma: 0.30,
            rho: -0.60,
            v0: 0.30,
        };

        let rate = config.analysis.risk_free_rate;  // Risk-free rate from config
        
        let result = match calibrate_heston(spot, rate, liquid_options.clone(), initial_guess) {
            Ok(res) => res,
            Err(e) => {
                println!("  ‚ùå Calibration failed: {}", e);
                continue;
            }
        };
        println!("  ‚úÖ Calibrated parameters:");
        println!("     Œ∫ (mean reversion) = {:.4}", result.params.kappa);
        println!("     Œ∏ (long-term vol)  = {:.4}", result.params.theta);
        println!("     œÉ (vol of vol)     = {:.4}", result.params.sigma);
        println!("     œÅ (correlation)    = {:.4}", result.params.rho);
        println!("     v‚ÇÄ (initial vol)   = {:.4}", result.params.v0);
        println!("     RMSE = {:.6}", result.rmse);
        
        // Save calibrated parameters to JSON
        let params_data = serde_json::json!({
            "symbol": symbol,
            "spot_price": spot,
            "calibration_date": chrono::Utc::now().to_rfc3339(),
            "heston_params": {
                "kappa": result.params.kappa,
                "theta": result.params.theta,
                "sigma": result.params.sigma,
                "rho": result.params.rho,
                "v0": result.params.v0
            },
            "rmse": result.rmse,
            "num_options_used": liquid_options.len()
        });
        
        let filename = format!("data/{}_heston_params.json", symbol.to_lowercase());
        if let Ok(json_str) = serde_json::to_string_pretty(&params_data) {
            if std::fs::write(&filename, json_str).is_ok() {
                println!("  üíæ Saved parameters to {}", filename);
            } else {
                println!("  ‚ùå Failed to save parameters to {}", filename);
            }
        }
        
        println!();
    }
    
    println!("==============================================");
    println!("HESTON CALIBRATION COMPLETED");
    println!("==============================================");
    
    Ok(())
}
