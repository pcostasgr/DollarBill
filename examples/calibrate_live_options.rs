// Test loading live options from Python-generated JSON
use dollarbill::market_data::options_json_loader::{load_options_from_json, filter_liquid_options};
use dollarbill::calibration::heston_calibrator::{calibrate_heston, CalibParams};
use dollarbill::market_data::symbols::load_enabled_stocks;
use serde::Deserialize;
use std::fs;

#[derive(Debug, Deserialize)]
struct SignalsConfig {
    analysis: AnalysisConfig,
    calibration: CalibrationConfig,
    options: OptionsConfig,
}

#[derive(Debug, Deserialize)]
struct AnalysisConfig {
    risk_free_rate: f64,
    liquidity_filters: LiquidityFilters,
    edge_thresholds: EdgeThresholds,
}

#[derive(Debug, Deserialize)]
struct LiquidityFilters {
    min_volume: i32,
    max_spread_pct: f64,
}

#[derive(Debug, Deserialize)]
struct EdgeThresholds {
    min_edge_dollars: f64,
    min_delta: f64,
}

#[derive(Debug, Deserialize)]
struct CalibrationConfig {
    tolerance: f64,
    max_iterations: usize,
}

#[derive(Debug, Deserialize)]
struct OptionsConfig {
    default_time_to_expiry_days: usize,
    min_time_to_expiry_days: usize,
    max_time_to_expiry_days: usize,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("==============================================");
    println!("LIVE OPTIONS CALIBRATION (Python â†’ Rust)");
    println!("==============================================\n");

    // Load configuration
    let config_content = fs::read_to_string("config/signals_config.json")
        .map_err(|e| format!("Failed to read signals config file: {}", e))?;
    let config: SignalsConfig = serde_json::from_str(&config_content)
        .map_err(|e| format!("Failed to parse signals config file: {}", e))?;

    println!("ðŸ“‹ Loaded signals configuration from config/signals_config.json");

    // 1. Load options from JSON (generated by Python)
    let json_file = "tsla_options_live.json";
    println!("Step 1: Loading options from {}...", json_file);

    let (spot, all_options) = load_options_from_json(json_file)?;
    println!();

    // 2. Filter for liquid options
    println!("Step 2: Filtering for liquid options...");
    let liquid_options = filter_liquid_options(all_options, config.analysis.liquidity_filters.min_volume, config.analysis.liquidity_filters.max_spread_pct);

    if liquid_options.is_empty() {
        return Err("No liquid options found!".into());
    }
    println!();

    // 3. Calibrate Heston model
    println!("Step 3: Calibrating Heston model to market prices...");
    let initial_guess = CalibParams {
        kappa: 2.0,
        theta: 0.25,
        sigma: 0.30,
        rho: -0.60,
        v0: 0.30,
    };

    let rate = config.analysis.risk_free_rate;  // Risk-free rate from config
    
    let result = calibrate_heston(spot, rate, liquid_options.clone(), initial_guess)?;
    println!();
    
    result.print_summary();
    println!();
    
    // 4. Show sample of model vs market prices
    println!("==============================================");
    println!("MODEL VS MARKET COMPARISON (First 10 Calls)");
    println!("==============================================");
    println!("{:<10} {:<12} {:<12} {:<12}", "Strike", "Market Mid", "Model Price", "Diff %");
    println!("{:-<50}", "");
    
    use dollarbill::models::heston_analytical::heston_call_carr_madan;
    use dollarbill::calibration::market_option::OptionType;
    
    let time_to_expiry = liquid_options[0].time_to_expiry;
    let heston_params = result.params.to_heston(spot, rate, time_to_expiry);
    
    let calls: Vec<_> = liquid_options
        .iter()
        .filter(|o| matches!(o.option_type, OptionType::Call))
        .take(10)
        .collect();
    
    for call in calls {
        let market_mid = call.mid_price();
        let model_price = heston_call_carr_madan(spot, call.strike, time_to_expiry, rate, &heston_params);
        let diff_pct = ((model_price - market_mid) / market_mid) * 100.0;
        
        println!(
            "${:<9.2} ${:<11.2} ${:<11.2} {:>11.2}%",
            call.strike, market_mid, model_price, diff_pct
        );
    }
    
    println!("\nâœ… Calibration complete! Model is fitted to live market data.");
    
    Ok(())
}
