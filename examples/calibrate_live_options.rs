// Test loading live options from Python-generated JSON
use dollarbill::market_data::options_json_loader::{load_options_from_json, filter_liquid_options};
use dollarbill::calibration::heston_calibrator::{calibrate_heston, CalibParams};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("==============================================");
    println!("LIVE OPTIONS CALIBRATION (Python → Rust)");
    println!("==============================================\n");
    
    // 1. Load options from JSON (generated by Python)
    let json_file = "tsla_options_live.json";
    println!("Step 1: Loading options from {}...", json_file);
    
    let (spot, all_options) = load_options_from_json(json_file)?;
    println!();
    
    // 2. Filter for liquid options
    println!("Step 2: Filtering for liquid options...");
    let liquid_options = filter_liquid_options(all_options, 50, 10.0);
    
    if liquid_options.is_empty() {
        return Err("No liquid options found!".into());
    }
    println!();
    
    // 3. Calibrate Heston model
    println!("Step 3: Calibrating Heston model to market prices...");
    let initial_guess = CalibParams {
        kappa: 2.0,
        theta: 0.25,
        sigma: 0.30,
        rho: -0.60,
        v0: 0.30,
    };
    
    let rate = 0.05;  // 5% risk-free rate
    
    let result = calibrate_heston(spot, rate, liquid_options.clone(), initial_guess)?;
    println!();
    
    result.print_summary();
    println!();
    
    // 4. Show sample of model vs market prices
    println!("==============================================");
    println!("MODEL VS MARKET COMPARISON (First 10 Calls)");
    println!("==============================================");
    println!("{:<10} {:<12} {:<12} {:<12}", "Strike", "Market Mid", "Model Price", "Diff %");
    println!("{:-<50}", "");
    
    use dollarbill::models::heston_analytical::heston_call_carr_madan;
    use dollarbill::calibration::market_option::OptionType;
    
    let time_to_expiry = liquid_options[0].time_to_expiry;
    let heston_params = result.params.to_heston(spot, rate, time_to_expiry);
    
    let calls: Vec<_> = liquid_options
        .iter()
        .filter(|o| matches!(o.option_type, OptionType::Call))
        .take(10)
        .collect();
    
    for call in calls {
        let market_mid = call.mid_price();
        let model_price = heston_call_carr_madan(spot, call.strike, time_to_expiry, rate, &heston_params);
        let diff_pct = ((model_price - market_mid) / market_mid) * 100.0;
        
        println!(
            "${:<9.2} ${:<11.2} ${:<11.2} {:>11.2}%",
            call.strike, market_mid, model_price, diff_pct
        );
    }
    
    println!("\n✅ Calibration complete! Model is fitted to live market data.");
    
    Ok(())
}
