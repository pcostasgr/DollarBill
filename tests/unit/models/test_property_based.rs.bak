//! Property-based tests for financial mathematics invariants
//! These tests verify mathematical relationships that must always hold

use dollarbill::models::bs_mod::{black_scholes_call, black_scholes_put};
use dollarbill::models::heston_analytical::heston_call_price;
use dollarbill::models::heston::{HestonParams, MonteCarloConfig};

const TOLERANCE: f64 = 1e-10;

#[test]
fn property_put_call_parity_holds() {
    // C - P = S - K*e^(-r*T) must always be true for European options
    let test_cases = vec![
        (100.0, 100.0, 0.05, 0.25, 0.2, 0.0), // ATM
        (100.0, 90.0, 0.05, 0.25, 0.2, 0.0),  // ITM call
        (100.0, 110.0, 0.05, 0.25, 0.2, 0.0), // OTM call
        (150.0, 120.0, 0.03, 0.5, 0.3, 0.01), // With dividends
        (50.0, 55.0, 0.08, 0.1, 0.4, 0.02),   // High vol, short term
    ];

    for (spot, strike, rate, time, vol, dividend) in test_cases {
        let call_price = black_scholes_call(spot, strike, rate, time, vol);
        let put_price = black_scholes_put(spot, strike, rate, time, vol);
        
        let pcp_left = call_price.price - put_price.price;
        let pcp_right = spot - strike * (-rate * time).exp();
        
        let diff = (pcp_left - pcp_right).abs();
        assert!(
            diff < TOLERANCE,
            "Put-call parity violated: C-P = {:.6}, S-K*e^(-r*T) = {:.6}, diff = {:.2e}",
            pcp_left, pcp_right, diff
        );
    }
}

#[test]
fn property_delta_bounds() {
    // Call delta: 0 ≤ Δ ≤ 1, Put delta: -1 ≤ Δ ≤ 0
    let test_cases = vec![
        (50.0, 40.0, 0.05, 0.25, 0.2, 0.0),   // Deep ITM call
        (50.0, 60.0, 0.05, 0.25, 0.2, 0.0),   // Deep OTM call
        (100.0, 100.0, 0.05, 0.25, 0.2, 0.0), // ATM
        (100.0, 80.0, 0.05, 0.1, 0.4, 0.0),   // High vol
        (100.0, 120.0, 0.05, 1.0, 0.1, 0.0),  // Low vol, long term
    ];

    for (spot, strike, rate, time, vol, dividend) in test_cases {
        let call_greeks = calculate_greeks(spot, strike, rate, time, vol, dividend, true);
        let put_greeks = calculate_greeks(spot, strike, rate, time, vol, dividend, false);
        
        // Call delta bounds
        assert!(
            call_greeks.delta >= 0.0 && call_greeks.delta <= 1.0,
            "Call delta out of bounds: {} for S={}, K={}", 
            call_greeks.delta, spot, strike
        );
        
        // Put delta bounds  
        assert!(
            put_greeks.delta >= -1.0 && put_greeks.delta <= 0.0,
            "Put delta out of bounds: {} for S={}, K={}", 
            put_greeks.delta, spot, strike
        );
    }
}

#[test]
fn property_gamma_always_positive() {
    // Γ ≥ 0 for all options (convexity)
    let test_cases = vec![
        (100.0, 80.0, 0.05, 0.25, 0.2, 0.0),
        (100.0, 100.0, 0.05, 0.25, 0.2, 0.0),
        (100.0, 120.0, 0.05, 0.25, 0.2, 0.0),
        (50.0, 50.0, 0.03, 0.1, 0.5, 0.01),
    ];

    for (spot, strike, rate, time, vol, dividend) in test_cases {
        let call_greeks = calculate_greeks(spot, strike, rate, time, vol, dividend, true);
        let put_greeks = calculate_greeks(spot, strike, rate, time, vol, dividend, false);
        
        assert!(
            call_greeks.gamma >= 0.0,
            "Negative call gamma: {} for S={}, K={}", 
            call_greeks.gamma, spot, strike
        );
        
        assert!(
            put_greeks.gamma >= 0.0,
            "Negative put gamma: {} for S={}, K={}", 
            put_greeks.gamma, spot, strike
        );
    }
}

#[test]
fn property_vega_symmetry() {
    // Vega should be identical for calls and puts at same strike
    let test_cases = vec![
        (100.0, 90.0, 0.05, 0.25, 0.2, 0.0),
        (100.0, 100.0, 0.05, 0.25, 0.2, 0.0),
        (100.0, 110.0, 0.05, 0.25, 0.2, 0.0),
    ];

    for (spot, strike, rate, time, vol, dividend) in test_cases {
        let call_greeks = calculate_greeks(spot, strike, rate, time, vol, dividend, true);
        let put_greeks = calculate_greeks(spot, strike, rate, time, vol, dividend, false);
        
        let vega_diff = (call_greeks.vega - put_greeks.vega).abs();
        assert!(
            vega_diff < TOLERANCE,
            "Vega asymmetry: call vega={:.6}, put vega={:.6}, diff={:.2e}",
            call_greeks.vega, put_greeks.vega, vega_diff
        );
    }
}

#[test]
fn property_theta_negative_for_long_positions() {
    // Theta should be negative for long options (time decay)
    let test_cases = vec![
        (100.0, 100.0, 0.05, 0.25, 0.2, 0.0),
        (100.0, 90.0, 0.05, 0.5, 0.3, 0.0),
        (100.0, 110.0, 0.05, 0.1, 0.4, 0.0),
    ];

    for (spot, strike, rate, time, vol, dividend) in test_cases {
        let call_greeks = calculate_greeks(spot, strike, rate, time, vol, dividend, true);
        let put_greeks = calculate_greeks(spot, strike, rate, time, vol, dividend, false);
        
        // Skip very deep ITM options which might have positive theta due to early exercise value
        if spot / strike > 0.5 && spot / strike < 2.0 {
            assert!(
                call_greeks.theta <= 0.0,
                "Positive call theta: {} for S={}, K={}", 
                call_greeks.theta, spot, strike
            );
            
            // Put theta can be positive for deep ITM puts due to dividends
            if dividend == 0.0 && spot > strike * 0.8 {
                assert!(
                    put_greeks.theta <= 0.0,
                    "Positive put theta: {} for S={}, K={}", 
                    put_greeks.theta, spot, strike
                );
            }
        }
    }
}

#[test]
fn property_option_price_monotonicity() {
    // Option prices should increase with volatility and time
    let base_params = (100.0, 100.0, 0.05, 0.25, 0.2, 0.0);
    let (spot, strike, rate, time, vol, dividend) = base_params;
    
    // Volatility monotonicity
    let vol1 = 0.1;
    let vol2 = 0.3;
    let call1 = black_scholes_call(spot, strike, rate, time, vol1);
    let call2 = black_scholes_call(spot, strike, rate, time, vol2);
    
    assert!(
        call2 > call1,
        "Call price not increasing with volatility: {:.4} @ σ={} vs {:.4} @ σ={}",
        call1, vol1, call2, vol2
    );
    
    // Time monotonicity (for most cases)
    let time1 = 0.1;
    let time2 = 0.5;
    let call_short = black_scholes_call(spot, strike, rate, time1, vol);
    let call_long = black_scholes_call(spot, strike, rate, time2, vol);
    
    assert!(
        call_long >= call_short,
        "Call price decreasing with time: {:.4} @ T={} vs {:.4} @ T={}",
        call_short, time1, call_long, time2
    );
}

#[test]
fn property_heston_reduces_to_bs() {
    // Heston should reduce to Black-Scholes when vol-of-vol = 0
    let spot = 100.0;
    let strike = 100.0;
    let rate = 0.05;
    let time = 0.25;
    let vol = 0.2;
    let dividend = 0.0;
    
    let bs_price = black_scholes_call(spot, strike, rate, time, vol);
    
    // Heston with zero vol-of-vol should match BS
    let heston_params = HestonParams {
        v0: vol * vol,        // Initial variance
        theta: vol * vol,     // Long-term variance  
        kappa: 2.0,          // Mean reversion speed
        sigma: 0.001,        // Vol-of-vol (near zero)
        rho: 0.0,            // Correlation
    };
    
    let config = MonteCarloConfig {
        n_paths: 100000,
        n_steps: 100,
        antithetic: true,
    };
    
    let heston_price = heston_call_price(
        spot, strike, rate, dividend, time, &heston_params
    ).unwrap_or(0.0);
    
    // Allow 5% tolerance due to numerical differences
    let tolerance = bs_price * 0.05;
    let diff = (heston_price - bs_price).abs();
    
    assert!(
        diff < tolerance,
        "Heston doesn't reduce to BS: BS={:.4}, Heston={:.4}, diff={:.4}",
        bs_price, heston_price, diff
    );
}

#[test] 
fn property_intrinsic_value_bounds() {
    // Option price should be at least intrinsic value
    let test_cases = vec![
        (110.0, 100.0, 0.05, 0.25, 0.2, 0.0), // ITM call
        (90.0, 100.0, 0.05, 0.25, 0.2, 0.0),  // ITM put
        (100.0, 100.0, 0.05, 0.25, 0.2, 0.0), // ATM
    ];
    
    for (spot, strike, rate, time, vol, dividend) in test_cases {
        let call_price = black_scholes_call(spot, strike, rate, time, vol);
        let put_price = black_scholes_put(spot, strike, rate, time, vol);
        
        let call_intrinsic = (spot - strike * (-rate * time).exp()).max(0.0);
        let put_intrinsic = (strike * (-rate * time).exp() - spot).max(0.0);
        
        assert!(
            call_price.price >= call_intrinsic,
            "Call price below intrinsic: price={:.4}, intrinsic={:.4}",
            call_price.price, call_intrinsic
        );
        
        assert!(
            put_price.price >= put_intrinsic,
            "Put price below intrinsic: price={:.4}, intrinsic={:.4}",
            put_price.price, put_intrinsic
        );
    }
}