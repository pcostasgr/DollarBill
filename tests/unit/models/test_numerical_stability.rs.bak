//! Numerical stability and convergence tests

use dollarbill::models::bs_mod::{black_scholes_call, black_scholes_put, implied_volatility};
use dollarbill::calibration::nelder_mead::NelderMead;
use dollarbill::models::heston::{HestonParams, MonteCarloConfig};
use dollarbill::models::heston_analytical::heston_call_price;

const HIGH_PRECISION: f64 = 1e-12;
const STANDARD_PRECISION: f64 = 1e-8;

#[test]
fn test_greeks_numerical_stability() {
    // Test Greeks calculation stability across different parameter ranges
    let test_scenarios = vec![
        // (spot, strike, rate, time, vol, dividend, description)
        (100.0, 100.0, 0.05, 0.25, 0.2, 0.0, "baseline ATM"),
        (1.0, 1.0, 0.05, 0.25, 0.2, 0.0, "low price"),
        (10000.0, 10000.0, 0.05, 0.25, 0.2, 0.0, "high price"),
        (100.0, 100.0, 0.001, 0.25, 0.2, 0.0, "low rate"),
        (100.0, 100.0, 0.15, 0.25, 0.2, 0.0, "high rate"),
        (100.0, 100.0, 0.05, 0.001, 0.2, 0.0, "short expiry"),
        (100.0, 100.0, 0.05, 5.0, 0.2, 0.0, "long expiry"),
        (100.0, 100.0, 0.05, 0.25, 0.05, 0.0, "low vol"),
        (100.0, 100.0, 0.05, 0.25, 1.0, 0.0, "high vol"),
    ];

    for (spot, strike, rate, time, vol, dividend, desc) in test_scenarios {
        let call_greeks = calculate_greeks(spot, strike, rate, time, vol, dividend, true);
        let put_greeks = calculate_greeks(spot, strike, rate, time, vol, dividend, false);
        
        // All Greeks should be finite
        assert!(call_greeks.price.is_finite(), "Call price not finite for {}", desc);
        assert!(call_greeks.delta.is_finite(), "Call delta not finite for {}", desc);
        assert!(call_greeks.gamma.is_finite(), "Call gamma not finite for {}", desc);
        assert!(call_greeks.theta.is_finite(), "Call theta not finite for {}", desc);
        assert!(call_greeks.vega.is_finite(), "Call vega not finite for {}", desc);
        assert!(call_greeks.rho.is_finite(), "Call rho not finite for {}", desc);
        
        assert!(put_greeks.price.is_finite(), "Put price not finite for {}", desc);
        assert!(put_greeks.delta.is_finite(), "Put delta not finite for {}", desc);
        assert!(put_greeks.gamma.is_finite(), "Put gamma not finite for {}", desc);
        assert!(put_greeks.theta.is_finite(), "Put theta not finite for {}", desc);
        assert!(put_greeks.vega.is_finite(), "Put vega not finite for {}", desc);
        assert!(put_greeks.rho.is_finite(), "Put rho not finite for {}", desc);
        
        // Greeks should have reasonable magnitudes
        assert!(call_greeks.gamma >= 0.0, "Negative gamma for {}", desc);
        assert!(put_greeks.gamma >= 0.0, "Negative gamma for {}", desc);
        assert!(call_greeks.vega >= 0.0, "Negative vega for {}", desc);
        assert!(put_greeks.vega >= 0.0, "Negative vega for {}", desc);
    }
}

#[test]
fn test_implied_volatility_convergence() {
    // Test Newton-Raphson convergence for IV calculation
    let spot = 100.0;
    let rate = 0.05;
    let time = 0.25;
    let dividend = 0.0;
    
    let test_strikes = vec![80.0, 90.0, 100.0, 110.0, 120.0];
    let test_vols = vec![0.1, 0.2, 0.3, 0.5, 0.8];
    
    for strike in &test_strikes {
        for &target_vol in &test_vols {
            // Generate market price using known volatility
            let market_call = black_scholes_call(spot, *strike, rate, time, target_vol, dividend);
            let market_put = black_scholes_put(spot, *strike, rate, time, target_vol, dividend);
            
            // Recover volatility from market price
            let recovered_call_vol = implied_volatility(
                market_call, spot, *strike, rate, time, dividend, true
            );
            let recovered_put_vol = implied_volatility(
                market_put, spot, *strike, rate, time, dividend, false
            );
            
            if let Ok(call_vol) = recovered_call_vol {
                let vol_error = (call_vol - target_vol).abs();
                assert!(
                    vol_error < 1e-6,
                    "Call IV convergence failed: target={:.4}, recovered={:.4}, error={:.2e} for K={}",
                    target_vol, call_vol, vol_error, strike
                );
            }
            
            if let Ok(put_vol) = recovered_put_vol {
                let vol_error = (put_vol - target_vol).abs();
                assert!(
                    vol_error < 1e-6,
                    "Put IV convergence failed: target={:.4}, recovered={:.4}, error={:.2e} for K={}",
                    target_vol, put_vol, vol_error, strike
                );
            }
        }
    }
}

#[test]
fn test_nelder_mead_convergence_robustness() {
    // Test optimizer convergence with different starting points
    let quadratic = |x: &[f64]| x[0] * x[0] + x[1] * x[1];
    
    let starting_points = vec![
        vec![vec![1.0, 1.0], vec![2.0, 1.0], vec![1.0, 2.0]],
        vec![vec![-5.0, -5.0], vec![-4.0, -5.0], vec![-5.0, -4.0]],
        vec![vec![10.0, -10.0], vec![11.0, -10.0], vec![10.0, -9.0]],
        vec![vec![0.1, 0.1], vec![0.2, 0.1], vec![0.1, 0.2]],
    ];
    
    for (i, initial_simplex) in starting_points.iter().enumerate() {
        let mut optimizer = NelderMead::new(initial_simplex.clone());
        let result = optimizer.optimize(&quadratic, HIGH_PRECISION, 1000);
        
        assert!(result.is_ok(), "Optimizer failed from starting point {}", i);
        
        if let Ok(solution) = result {
            let error = (solution[0].abs() + solution[1].abs());
            assert!(
                error < STANDARD_PRECISION,
                "Poor convergence from starting point {}: solution=[{:.6}, {:.6}], error={:.2e}",
                i, solution[0], solution[1], error
            );
        }
    }
}

#[test]
fn test_heston_fft_numerical_stability() {
    // Test Heston FFT implementation across parameter ranges
    let spot = 100.0;
    let strike = 100.0;
    let rate = 0.05;
    let time = 0.25;
    let dividend = 0.0;
    
    let test_params = vec![
        HestonParams {
            v0: 0.04, theta: 0.04, kappa: 2.0, sigma: 0.3, rho: -0.5
        },
        HestonParams {
            v0: 0.01, theta: 0.01, kappa: 5.0, sigma: 0.1, rho: 0.0
        },
        HestonParams {
            v0: 0.09, theta: 0.04, kappa: 1.0, sigma: 0.6, rho: -0.8
        },
        HestonParams {
            v0: 0.04, theta: 0.09, kappa: 3.0, sigma: 0.2, rho: 0.3
        },
    ];
    
    for (i, params) in test_params.iter().enumerate() {
        let price_result = heston_call_price(spot, strike, rate, dividend, time, params);
        
        assert!(price_result.is_ok(), "Heston pricing failed for parameter set {}", i);
        
        if let Ok(price) = price_result {
            assert!(price.is_finite(), "Heston price not finite for parameter set {}", i);
            assert!(price > 0.0, "Heston price not positive for parameter set {}: {:.6}", i, price);
            
            // Price should be reasonable (not too extreme)
            assert!(price < spot * 2.0, "Heston price too high for parameter set {}: {:.4}", i, price);
        }
    }
}

#[test]
fn test_precision_consistency() {
    // Test that results are consistent across different precision requirements
    let spot = 100.0;
    let strike = 100.0;
    let rate = 0.05;
    let time = 0.25;
    let vol = 0.2;
    let dividend = 0.0;
    
    // Calculate same price multiple times - should be identical
    let prices: Vec<f64> = (0..10).map(|_| {
        black_scholes_call(spot, strike, rate, time, vol, dividend)
    }).collect();
    
    let first_price = prices[0];
    for (i, &price) in prices.iter().enumerate() {
        assert_eq!(
            price, first_price,
            "Price calculation not deterministic: iteration {} gave {:.15}, expected {:.15}",
            i, price, first_price
        );
    }
}

#[test]
fn test_parameter_sensitivity_smoothness() {
    // Test that small parameter changes produce smooth price changes
    let base_spot = 100.0;
    let strike = 100.0;
    let rate = 0.05;
    let time = 0.25;
    let vol = 0.2;
    let dividend = 0.0;
    
    let epsilon = 1e-6;
    
    // Test spot sensitivity (should approximate delta)
    let price_down = black_scholes_call(base_spot - epsilon, strike, rate, time, vol, dividend);
    let price_up = black_scholes_call(base_spot + epsilon, strike, rate, time, vol, dividend);
    let numerical_delta = (price_up - price_down) / (2.0 * epsilon);
    
    let analytical_greeks = calculate_greeks(base_spot, strike, rate, time, vol, dividend, true);
    
    let delta_error = (numerical_delta - analytical_greeks.delta).abs();
    assert!(
        delta_error < 1e-4,
        "Delta approximation error too large: numerical={:.6}, analytical={:.6}, error={:.2e}",
        numerical_delta, analytical_greeks.delta, delta_error
    );
    
    // Test volatility sensitivity (should approximate vega)
    let price_vol_down = black_scholes_call(base_spot, strike, rate, time, vol - epsilon, dividend);
    let price_vol_up = black_scholes_call(base_spot, strike, rate, time, vol + epsilon, dividend);
    let numerical_vega = (price_vol_up - price_vol_down) / (2.0 * epsilon);
    
    let vega_error = (numerical_vega - analytical_greeks.vega).abs();
    assert!(
        vega_error < 1e-2, // Vega is typically larger, so allow more error
        "Vega approximation error too large: numerical={:.6}, analytical={:.6}, error={:.2e}",
        numerical_vega, analytical_greeks.vega, vega_error
    );
}

#[test]
fn test_optimization_iteration_limits() {
    // Test that optimizer respects iteration limits and doesn't run forever
    use std::time::Instant;
    
    // Create a difficult optimization problem
    let difficult_function = |x: &[f64]| {
        // Noisy quadratic with many local minima
        let noise = (x[0] * 37.0).sin() * 0.1 + (x[1] * 43.0).sin() * 0.1;
        x[0] * x[0] + x[1] * x[1] + noise
    };
    
    let start_time = Instant::now();
    let mut optimizer = NelderMead::new(vec![vec![10.0, 10.0], vec![11.0, 10.0], vec![10.0, 11.0]]);
    
    // Set low iteration limit
    let result = optimizer.optimize(&difficult_function, 1e-12, 50);
    let duration = start_time.elapsed();
    
    // Should complete quickly even if not converged
    assert!(
        duration.as_secs() < 1,
        "Optimizer took too long: {:.3}s",
        duration.as_secs_f64()
    );
    
    // Should either converge or hit iteration limit
    assert!(
        result.is_ok() || result.is_err(),
        "Optimizer should return a result within iteration limit"
    );
}

#[test]
fn test_monte_carlo_convergence() {
    // Test that Monte Carlo paths converge with increasing sample size
    let params = HestonParams {
        v0: 0.04,
        theta: 0.04,
        kappa: 2.0,
        sigma: 0.3,
        rho: -0.5,
    };
    
    let spot = 100.0;
    let strike = 100.0;
    let rate = 0.05;
    let time = 0.25;
    let dividend = 0.0;
    
    // Compare with analytical result
    let analytical_price = heston_call_price(spot, strike, rate, dividend, time, &params);
    
    if let Ok(target_price) = analytical_price {
        // Test convergence - this is a placeholder since we don't have MC implementation
        // In practice, you'd test that MC prices converge to analytical price
        
        assert!(target_price > 0.0, "Analytical price should be positive");
        assert!(target_price.is_finite(), "Analytical price should be finite");
        
        // The actual MC convergence test would look like:
        // let sample_sizes = vec![1000, 10000, 100000];
        // for n in sample_sizes {
        //     let mc_price = heston_monte_carlo(spot, strike, rate, dividend, time, &params, n);
        //     let error = (mc_price - target_price).abs();
        //     // Error should decrease with âˆšn
        // }
    }
}