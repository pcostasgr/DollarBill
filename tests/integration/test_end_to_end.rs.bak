//! End-to-end integration tests for complete pipeline validation

use std::path::Path;
use dollarbill::models::bs_mod::{black_scholes_call, calculate_greeks};
use dollarbill::models::heston_analytical::heston_call_price;
use dollarbill::models::heston::HestonParams;
use dollarbill::calibration::nelder_mead::NelderMead;
use dollarbill::market_data::csv_loader::load_historical_data;

#[test]
fn test_complete_trading_pipeline() {
    // Simulate complete pipeline: Data -> Calibration -> Signals -> Risk
    
    // Step 1: Market data (simulated)
    let symbols = vec!["AAPL", "TSLA", "NVDA"];
    let spot_prices = vec![150.0, 200.0, 800.0];
    let current_vols = vec![0.25, 0.45, 0.35];
    
    // Step 2: Options chain analysis  
    let strikes_per_symbol = 5;
    let mut total_positions = 0;
    let mut portfolio_delta = 0.0;
    let mut portfolio_vega = 0.0;
    
    for (i, symbol) in symbols.iter().enumerate() {
        let spot = spot_prices[i];
        let vol = current_vols[i];
        
        // Generate strikes around ATM
        for j in 0..strikes_per_symbol {
            let moneyness = 0.9 + (j as f64) * 0.05; // 90% to 110% moneyness
            let strike = spot * moneyness;
            
            // Calculate fair value and Greeks
            let call_greeks = calculate_greeks(spot, strike, 0.05, 0.25, vol, 0.0, true);
            let put_greeks = calculate_greeks(spot, strike, 0.05, 0.25, vol, 0.0, false);
            
            // Simple signal: buy undervalued options
            let market_call_price = call_greeks.price * 0.95; // Assume 5% undervalued
            let market_put_price = put_greeks.price * 1.05;   // Assume 5% overvalued
            
            if call_greeks.price > market_call_price * 1.1 {
                // Buy undervalued call
                portfolio_delta += call_greeks.delta;
                portfolio_vega += call_greeks.vega;
                total_positions += 1;
            }
            
            if put_greeks.price < market_put_price * 0.9 {
                // Sell overvalued put
                portfolio_delta -= put_greeks.delta;
                portfolio_vega -= put_greeks.vega;
                total_positions += 1;
            }
        }
    }
    
    // Step 3: Portfolio validation
    assert!(total_positions > 0, "No positions generated in pipeline");
    assert!(portfolio_delta.is_finite(), "Portfolio delta not finite");
    assert!(portfolio_vega.is_finite(), "Portfolio vega not finite");
    
    println!("Pipeline Results:");
    println!("  Symbols analyzed: {}", symbols.len());
    println!("  Total positions: {}", total_positions);
    println!("  Portfolio delta: {:.2}", portfolio_delta);
    println!("  Portfolio vega: {:.2}", portfolio_vega);
    
    // Step 4: Risk checks
    assert!(
        portfolio_delta.abs() < 50.0, // Reasonable delta exposure
        "Portfolio delta too large: {:.2}",
        portfolio_delta
    );
    
    assert!(
        portfolio_vega.abs() < 1000.0, // Reasonable vega exposure
        "Portfolio vega too large: {:.2}",
        portfolio_vega
    );
}

#[test]
fn test_backtest_to_live_trading_consistency() {
    // Same strategy should behave identically in backtest vs live
    
    let spot = 100.0;
    let rate = 0.05;
    let time = 0.25;
    let vol = 0.2;
    let dividend = 0.0;
    
    // Strategy: Buy calls when IV < 20%, sell when IV > 30%
    let market_vol_scenarios = vec![0.15, 0.25, 0.35];
    
    for market_vol in market_vol_scenarios {
        let fair_price = black_scholes_call(spot, spot, rate, time, vol, dividend);
        let market_price = black_scholes_call(spot, spot, rate, time, market_vol, dividend);
        
        let signal_strength = (fair_price - market_price) / fair_price;
        
        // Backtest logic
        let backtest_action = if signal_strength > 0.1 {
            "BUY"
        } else if signal_strength < -0.1 {
            "SELL"  
        } else {
            "HOLD"
        };
        
        // Live trading logic (should be identical)
        let live_action = if signal_strength > 0.1 {
            "BUY"
        } else if signal_strength < -0.1 {
            "SELL"
        } else {
            "HOLD"
        };
        
        assert_eq!(
            backtest_action, live_action,
            "Strategy inconsistency: backtest={}, live={} for market_vol={}",
            backtest_action, live_action, market_vol
        );
    }
}

#[test]
fn test_data_pipeline_integrity() {
    // Test data flows correctly through the system
    
    // Simulated CSV data loading (would use real files in practice)
    let mock_csv_data = vec![
        ("2024-01-01", 100.0, 105.0, 98.0, 102.0, 1000000),
        ("2024-01-02", 102.0, 104.0, 101.0, 103.0, 1200000),
        ("2024-01-03", 103.0, 106.0, 102.0, 105.0, 950000),
        ("2024-01-04", 105.0, 107.0, 104.0, 106.0, 1100000),
        ("2024-01-05", 106.0, 108.0, 105.0, 107.0, 1050000),
    ];
    
    // Verify data consistency
    for (i, (_date, open, high, low, close, _volume)) in mock_csv_data.iter().enumerate() {
        assert!(high >= open, "High < Open on day {}", i);
        assert!(high >= close, "High < Close on day {}", i);
        assert!(low <= open, "Low > Open on day {}", i);
        assert!(low <= close, "Low > Close on day {}", i);
        assert!(*open > 0.0, "Non-positive price on day {}", i);
    }
    
    // Calculate volatility from price series
    let prices: Vec<f64> = mock_csv_data.iter().map(|(_, _, _, _, close, _)| *close).collect();
    let returns: Vec<f64> = prices.windows(2)
        .map(|pair| (pair[1] / pair[0]).ln())
        .collect();
    
    if returns.len() > 1 {
        let mean_return = returns.iter().sum::<f64>() / returns.len() as f64;
        let variance = returns.iter()
            .map(|r| (r - mean_return).powi(2))
            .sum::<f64>() / (returns.len() - 1) as f64;
        let volatility = variance.sqrt() * (252.0_f64).sqrt(); // Annualized
        
        assert!(volatility > 0.0, "Calculated volatility not positive");
        assert!(volatility < 2.0, "Calculated volatility unreasonably high: {:.3}", volatility);
        
        println!("Data pipeline validation:");
        println!("  Price range: {:.2} - {:.2}", 
                 prices.iter().cloned().fold(f64::INFINITY, f64::min),
                 prices.iter().cloned().fold(f64::NEG_INFINITY, f64::max));
        println!("  Calculated volatility: {:.1}%", volatility * 100.0);
    }
}

#[test]
fn test_calibration_to_pricing_consistency() {
    // Test that calibrated models price correctly
    
    // Mock market option prices
    let spot = 100.0;
    let rate = 0.05;
    let time = 0.25;
    let dividend = 0.0;
    
    let market_options = vec![
        (90.0, 12.5),   // ITM call
        (100.0, 5.8),   // ATM call  
        (110.0, 2.1),   // OTM call
    ];
    
    // Step 1: Calibrate to market prices
    let calibration_objective = |params: &[f64]| -> f64 {
        if params.len() != 1 { return 1e6; }
        let vol = params[0];
        
        if vol <= 0.0 || vol > 2.0 { return 1e6; }
        
        let mut total_error = 0.0;
        for &(strike, market_price) in &market_options {
            let model_price = black_scholes_call(spot, strike, rate, time, vol, dividend);
            let error = (model_price - market_price).powi(2);
            total_error += error;
        }
        total_error
    };
    
    let mut optimizer = NelderMead::new(vec![vec![0.2], vec![0.3]]);
    let calibration_result = optimizer.optimize(&calibration_objective, 1e-6, 1000);
    
    assert!(calibration_result.is_ok(), "Calibration failed");
    
    if let Ok(calibrated_params) = calibration_result {
        let calibrated_vol = calibrated_params[0];
        
        // Step 2: Verify calibrated model prices options correctly
        for &(strike, market_price) in &market_options {
            let model_price = black_scholes_call(spot, strike, rate, time, calibrated_vol, dividend);
            let error_pct = (model_price - market_price).abs() / market_price * 100.0;
            
            assert!(
                error_pct < 5.0, // Within 5% of market price
                "Calibrated model error too large: {:.1}% for strike {}",
                error_pct, strike
            );
        }
        
        println!("Calibration validation:");
        println!("  Calibrated volatility: {:.1}%", calibrated_vol * 100.0);
        println!("  Max pricing error: <5%");
    }
}

#[test]
fn test_multi_model_consistency() {
    // Test that different models give consistent results when they should
    
    let spot = 100.0;
    let strike = 100.0;
    let rate = 0.05;
    let time = 0.25;
    let vol = 0.2;
    let dividend = 0.0;
    
    // Black-Scholes price
    let bs_price = black_scholes_call(spot, strike, rate, time, vol, dividend);
    
    // Heston with zero vol-of-vol should approximate Black-Scholes
    let heston_params = HestonParams {
        v0: vol * vol,
        theta: vol * vol,
        kappa: 2.0,
        sigma: 0.01, // Very low vol-of-vol
        rho: 0.0,
    };
    
    let heston_result = heston_call_price(spot, strike, rate, dividend, time, &heston_params);
    
    if let Ok(heston_price) = heston_result {
        let price_diff_pct = (heston_price - bs_price).abs() / bs_price * 100.0;
        
        // Should be close when vol-of-vol is low
        assert!(
            price_diff_pct < 10.0, // Within 10% when vol-of-vol is low
            "Model inconsistency: BS={:.4}, Heston={:.4}, diff={:.1}%",
            bs_price, heston_price, price_diff_pct
        );
        
        println!("Multi-model consistency:");
        println!("  Black-Scholes: {:.4}", bs_price);
        println!("  Heston (low vol-vol): {:.4}", heston_price);
        println!("  Difference: {:.1}%", price_diff_pct);
    }
}

#[test]
fn test_error_propagation() {
    // Test that errors are handled gracefully throughout pipeline
    
    let test_scenarios = vec![
        ("negative_vol", -0.1),
        ("zero_time", 0.0),
        ("negative_spot", -100.0),
        ("extreme_vol", 10.0),
    ];
    
    for (scenario, bad_param) in test_scenarios {
        match scenario {
            "negative_vol" => {
                let result = black_scholes_call(100.0, 100.0, 0.05, 0.25, bad_param, 0.0);
                // Should either return reasonable value or be detectable as invalid
                assert!(result.is_finite() || result.is_nan(), 
                       "Negative vol should produce finite or NaN result");
            },
            "zero_time" => {
                let result = black_scholes_call(100.0, 100.0, 0.05, bad_param, 0.2, 0.0);
                assert!(result >= 0.0, "Zero time should produce non-negative result");
            },
            "negative_spot" => {
                let result = black_scholes_call(bad_param, 100.0, 0.05, 0.25, 0.2, 0.0);
                // Should handle gracefully (may be NaN or negative)
                assert!(result.is_finite() || result.is_nan(),
                       "Negative spot should not crash");
            },
            "extreme_vol" => {
                let result = black_scholes_call(100.0, 100.0, 0.05, 0.25, bad_param, 0.0);
                assert!(result.is_finite(), "Extreme vol should produce finite result");
                assert!(result >= 0.0, "Option price should be non-negative");
            },
            _ => {}
        }
    }
}

#[test]
fn test_configuration_driven_pipeline() {
    // Test that configuration changes affect pipeline correctly
    
    // Mock configuration scenarios
    struct Config {
        symbols: Vec<&'static str>,
        min_edge: f64,
        max_positions: usize,
        risk_limit: f64,
    }
    
    let configs = vec![
        Config {
            symbols: vec!["AAPL"],
            min_edge: 0.05,
            max_positions: 5,
            risk_limit: 100.0,
        },
        Config {
            symbols: vec!["AAPL", "TSLA", "NVDA"],
            min_edge: 0.10,
            max_positions: 10,
            risk_limit: 200.0,
        },
    ];
    
    for (i, config) in configs.iter().enumerate() {
        let mut positions_opened = 0;
        let mut total_edge = 0.0;
        
        // Simulate trading pipeline with configuration
        for symbol in &config.symbols {
            let spot = 100.0 + (symbol.len() as f64) * 10.0; // Mock price based on symbol
            
            // Generate potential trades
            for j in 0..5 {
                let strike = spot * (0.95 + j as f64 * 0.025);
                let fair_price = black_scholes_call(spot, strike, 0.05, 0.25, 0.2, 0.0);
                let market_price = fair_price * 0.95; // 5% edge
                
                let edge = (fair_price - market_price) / market_price;
                
                if edge >= config.min_edge && positions_opened < config.max_positions {
                    positions_opened += 1;
                    total_edge += edge;
                }
            }
        }
        
        // Verify configuration effects
        assert!(
            positions_opened <= config.max_positions,
            "Config {} exceeded position limit: {} > {}",
            i, positions_opened, config.max_positions
        );
        
        if positions_opened > 0 {
            let avg_edge = total_edge / positions_opened as f64;
            assert!(
                avg_edge >= config.min_edge,
                "Config {} violated minimum edge: {:.3} < {:.3}",
                i, avg_edge, config.min_edge
            );
        }
        
        println!("Configuration {} results:", i);
        println!("  Symbols: {:?}", config.symbols);
        println!("  Positions opened: {} / {}", positions_opened, config.max_positions);
        if positions_opened > 0 {
            println!("  Average edge: {:.1}%", (total_edge / positions_opened as f64) * 100.0);
        }
    }
}